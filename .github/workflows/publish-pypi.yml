# PyPI Publishing Workflow
# Publishes the package to PyPI when a release is created

name: Publish to PyPI

on:
  release:
    types: [published]
  # Allow manual triggering to bump version and create release
  workflow_dispatch:
    inputs:
      bump_part:
        description: 'Version part to bump (major, minor, patch)'
        required: false
        default: 'patch'
        type: choice
        options:
          - patch
          - minor
          - major

permissions:
  contents: write

concurrency:
  group: ${{ github.workflow }}-${{ github.event.pull_request.number || github.ref || github.run_id }}
  cancel-in-progress: true

jobs:
  bump-and-release:
    name: Bump version and create release
    # Only run on manual workflow dispatch
    if: github.event_name == 'workflow_dispatch'
    runs-on: ubuntu-latest
    timeout-minutes: 30
    outputs:
      version: ${{ steps.bump.outputs.version }}
      tag: ${{ steps.bump.outputs.tag }}

    permissions:
      contents: write  # Required to commit, push, create tags and releases

    steps:
      - name: Check out repository
        uses: actions/checkout@v5
        with:
          fetch-depth: 0  # Fetch all history for proper tagging
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Set up Python
        uses: actions/setup-python@v6
        with:
          python-version: "3.12"
          cache: pip
          cache-dependency-path: |
            pyproject.toml
            requirements-dev.txt

      - name: Configure Git
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

      - name: Bump version
        id: bump
        run: |
          python scripts/bump_version.py --part ${{ github.event.inputs.bump_part || 'patch' }}
          NEW_VERSION=$(python -c "from scripts.bump_version import get_current_version; from pathlib import Path; print(get_current_version(Path('pyproject.toml')))")
          echo "version=$NEW_VERSION" >> $GITHUB_OUTPUT
          echo "tag=v$NEW_VERSION" >> $GITHUB_OUTPUT

      - name: Commit version bump
        run: |
          git add pyproject.toml scripts/__init__.py
          git commit -m "chore: bump version to ${{ steps.bump.outputs.version }}"
          git push

      - name: Create and push tag
        run: |
          git tag -a "${{ steps.bump.outputs.tag }}" -m "Release ${{ steps.bump.outputs.tag }}"
          git push origin "${{ steps.bump.outputs.tag }}"

      - name: Create GitHub Release
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          gh release create "${{ steps.bump.outputs.tag }}" \
            --title "${{ steps.bump.outputs.tag }}" \
            --notes "Release ${{ steps.bump.outputs.tag }}" \
            --draft=false \
            --prerelease=false

      - name: Trigger Build Executables Workflow
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          echo "Triggering build-executables workflow for tag ${{ steps.bump.outputs.tag }}"
          gh workflow run build-executables.yml --ref "${{ steps.bump.outputs.tag }}"

  validate-version:
    name: Validate version consistency
    # Run on release events OR after bump-and-release on workflow_dispatch
    needs: [bump-and-release]
    if: |
      always() &&
      (github.event_name == 'release' ||
       (github.event_name == 'workflow_dispatch' && needs.bump-and-release.result == 'success'))
    runs-on: ubuntu-latest
    timeout-minutes: 15

    steps:
      - name: Check out repository
        uses: actions/checkout@v5
        with:
          # For workflow_dispatch, checkout the newly created tag
          # For release events, checkout the release ref
          ref: ${{ github.event_name == 'workflow_dispatch' && needs.bump-and-release.outputs.tag || github.ref }}

      - name: Set up Python
        uses: actions/setup-python@v6
        with:
          python-version: "3.12"
          cache: pip
          cache-dependency-path: pyproject.toml

      - name: Check version consistency
        run: |
          # For workflow_dispatch, use the tag from bump-and-release output
          # For release events, use github.ref_name
          if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            TAG="${{ needs.bump-and-release.outputs.tag }}"
          else
            TAG="${{ github.ref_name }}"
          fi

          python scripts/check_version_consistency.py --tag "$TAG"

          echo "## Version Validation ✅" >> "$GITHUB_STEP_SUMMARY"
          echo "" >> "$GITHUB_STEP_SUMMARY"
          echo "Version consistency check passed for tag $TAG" >> "$GITHUB_STEP_SUMMARY"
          echo "" >> "$GITHUB_STEP_SUMMARY"
          echo "All version files are in sync:" >> "$GITHUB_STEP_SUMMARY"
          echo "- \`pyproject.toml\`" >> "$GITHUB_STEP_SUMMARY"
          echo "- \`scripts/__init__.py\`" >> "$GITHUB_STEP_SUMMARY"
          echo "- Git tag: \`$TAG\`" >> "$GITHUB_STEP_SUMMARY"

  build:
    name: Build distribution packages
    # Build needs validation to pass (on release events) or run after bump on workflow_dispatch
    needs: [bump-and-release, validate-version]
    if: |
      always() &&
      (needs.validate-version.result == 'success' || needs.validate-version.result == 'skipped') &&
      (github.event_name == 'release' ||
       (github.event_name == 'workflow_dispatch' && needs.bump-and-release.result == 'success'))
    runs-on: ubuntu-latest
    timeout-minutes: 30

    steps:
      - name: Check out repository
        uses: actions/checkout@v5
        with:
          # For workflow_dispatch, checkout the newly created tag
          # For release events, checkout the release ref
          ref: ${{ github.event_name == 'workflow_dispatch' && needs.bump-and-release.outputs.tag || github.ref }}

      - name: Set up Python
        uses: actions/setup-python@v6
        with:
          python-version: "3.12"
          cache: pip
          cache-dependency-path: |
            pyproject.toml
            requirements-dev.txt

      - name: Install build dependencies
        run: |
          python -m pip install --upgrade pip
          python -m pip install build

      - name: Build distribution packages
        run: python -m build

      - name: Smoke test built package
        shell: bash
        run: |
          set -euo pipefail
          python -m venv .venv-smoke
          source .venv-smoke/bin/activate
          python -m pip install --upgrade pip
          python -m pip install dist/*.whl

          SMOKE_LOG=smoke-test.log
          {
            echo '### games-collection --help'
            games-collection --help
            echo
            echo '### python -m card_games.go_fish --help'
            python -m card_games.go_fish --help
          } 2>&1 | tee "$SMOKE_LOG"

          {
            echo '## Smoke test output'
            echo '```'
            cat "$SMOKE_LOG"
            echo '```'
          } >> "$GITHUB_STEP_SUMMARY"

      - name: Upload distribution packages
        uses: actions/upload-artifact@v4
        with:
          name: python-package-distributions
          path: dist/

  publish-to-pypi:
    name: Publish to PyPI
    # Publish on release events OR after successful build on workflow_dispatch
    needs: [bump-and-release, build]
    if: |
      always() &&
      needs.build.result == 'success' &&
      ((github.event_name == 'release' && github.event.action == 'published') ||
       (github.event_name == 'workflow_dispatch' && needs.bump-and-release.result == 'success'))
    runs-on: ubuntu-latest
    timeout-minutes: 20

    # GitHub Environment configuration required:
    # 1. Create 'pypi' environment in repository Settings > Environments
    # 2. Configure PyPI trusted publishing with this environment name
    # 3. No secrets needed - uses OIDC (id-token: write permission)
    environment:
      name: pypi
      url: https://pypi.org/p/games-collection

    permissions:
      id-token: write  # Required for PyPI trusted publishing (OIDC)

    steps:
      - name: Download distribution packages
        uses: actions/download-artifact@v4
        with:
          name: python-package-distributions
          path: dist/

      - name: Publish to PyPI
        uses: pypa/gh-action-pypi-publish@release/v1

  github-release:
    name: Sign and upload to GitHub Release
    # Run on release events OR after successful PyPI publish on workflow_dispatch
    needs: [bump-and-release, publish-to-pypi]
    if: |
      always() &&
      needs.publish-to-pypi.result == 'success' &&
      ((github.event_name == 'release' && github.event.action == 'published') ||
       (github.event_name == 'workflow_dispatch' && needs.bump-and-release.result == 'success'))
    runs-on: ubuntu-latest
    timeout-minutes: 20

    permissions:
      contents: write  # Required to upload release assets
      id-token: write  # Required for Sigstore signing

    steps:
      - name: Download distribution packages
        uses: actions/download-artifact@v4
        with:
          name: python-package-distributions
          path: dist/

      - name: Check for existing release assets
        id: check_assets
        env:
          GITHUB_TOKEN: ${{ github.token }}
          GH_TOKEN: ${{ github.token }}
        run: |
          # Determine release tag based on event type
          if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            RELEASE_TAG="${{ needs.bump-and-release.outputs.tag }}"
          else
            RELEASE_TAG="${{ github.ref_name }}"
          fi

          echo "Checking for existing assets in release $RELEASE_TAG..."

          # Get list of existing assets
          EXISTING_ASSETS=$(gh release view "$RELEASE_TAG" \
            --repo "${{ github.repository }}" \
            --json assets \
            --jq '.assets[].name' || echo "")

          if [ -n "$EXISTING_ASSETS" ]; then
            echo "::warning::The following assets already exist in release $RELEASE_TAG and will be overwritten:"
            echo "$EXISTING_ASSETS" | while read -r asset; do
              echo "::warning::  - $asset"
            done
          else
            echo "✓ No existing assets found."
          fi

          # Store tag for later use
          echo "release_tag=$RELEASE_TAG" >> $GITHUB_OUTPUT

      - name: Sign the dists with Sigstore
        uses: sigstore/gh-action-sigstore-python@v3.0.1
        with:
          inputs: >-
            ./dist/*.tar.gz
            ./dist/*.whl

      - name: Upload signed packages to GitHub Release
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          # Upload all files from dist/ with clobber flag to overwrite existing files
          gh release upload "${{ steps.check_assets.outputs.release_tag }}" \
            dist/* \
            --clobber \
            --repo "${{ github.repository }}"

          echo "## Release Assets Uploaded ✅" >> "$GITHUB_STEP_SUMMARY"
          echo "" >> "$GITHUB_STEP_SUMMARY"
          echo "All distribution packages and signatures uploaded to release ${{ steps.check_assets.outputs.release_tag }}" >> "$GITHUB_STEP_SUMMARY"
